From e2b9b1acf4febb26399d8b633803ab17009c3638 Mon Sep 17 00:00:00 2001
From: Maryam Tahhan <mtahhan@redhat.com>
Date: Fri, 9 Feb 2024 06:39:51 -0500
Subject: [PATCH 2/2] net/af_xdp: support AF_XDP DP pinned maps

Enable the AF_XDP PMD to retrieve the xskmap
from a pinned eBPF map. This map is expected
to be pinned by an external entity like the
AF_XDP Device Plugin. This enabled unprivileged
pods to create and use AF_XDP sockets.

Signed-off-by: Maryam Tahhan <mtahhan@redhat.com>
---
 ...enable-a-sock-path-alongside-use_cni.patch | 272 +++++++++++++++
 ...af_xdp-support-AF_XDP-DP-pinned-maps.patch | 322 ++++++++++++++++++
 drivers/net/af_xdp/rte_eth_af_xdp.c           | 118 +++++--
 3 files changed, 680 insertions(+), 32 deletions(-)
 create mode 100644 0001-net-af_xdp-enable-a-sock-path-alongside-use_cni.patch
 create mode 100644 0002-net-af_xdp-support-AF_XDP-DP-pinned-maps.patch

diff --git a/0001-net-af_xdp-enable-a-sock-path-alongside-use_cni.patch b/0001-net-af_xdp-enable-a-sock-path-alongside-use_cni.patch
new file mode 100644
index 0000000000..3f5b34b592
--- /dev/null
+++ b/0001-net-af_xdp-enable-a-sock-path-alongside-use_cni.patch
@@ -0,0 +1,272 @@
+From ec219e8bbc5645e26a1893ca592ded23718adf48 Mon Sep 17 00:00:00 2001
+From: Maryam Tahhan <mtahhan@redhat.com>
+Date: Fri, 9 Feb 2024 06:15:18 -0500
+Subject: [PATCH 1/2] net/af_xdp: enable a sock path alongside use_cni
+
+With the original 'use_cni' implementation, (using a
+hardcoded socket rather than a configurable one),
+if a single pod is requesting multiple net devices
+from the AF_XDP Device Plugin, and these devices are
+from different pools, then the container attempts to
+mount all the netdev UDSes in the pod as /tmp/afxdp.sock.
+Which means that at best only 1 netdev will handshake
+correctly with the AF_XDP DP. This patch fixes this by
+making the socket parameter configurable alongside the
+'use_cni' param. If a 'dp_path' param is not provided
+then it's automatically populated by the AF_XDP PMD
+with what's assumed to be the default UDS path for the
+AF_XDP Device Plugin.
+
+Signed-off-by: Maryam Tahhan <mtahhan@redhat.com>
+---
+ drivers/net/af_xdp/rte_eth_af_xdp.c | 58 +++++++++++++++++++----------
+ 1 file changed, 39 insertions(+), 19 deletions(-)
+
+diff --git a/drivers/net/af_xdp/rte_eth_af_xdp.c b/drivers/net/af_xdp/rte_eth_af_xdp.c
+index 2a20a6960c..0ade2b367c 100644
+--- a/drivers/net/af_xdp/rte_eth_af_xdp.c
++++ b/drivers/net/af_xdp/rte_eth_af_xdp.c
+@@ -83,12 +83,13 @@ RTE_LOG_REGISTER_DEFAULT(af_xdp_logtype, NOTICE);
+ 
+ #define ETH_AF_XDP_MP_KEY "afxdp_mp_send_fds"
+ 
++#define DP_BASE_PATH			"/tmp"
++#define DP_UDS_SOCK             "afxdp.sock"
+ #define MAX_LONG_OPT_SZ			64
+ #define UDS_MAX_FD_NUM			2
+ #define UDS_MAX_CMD_LEN			64
+ #define UDS_MAX_CMD_RESP		128
+ #define UDS_XSK_MAP_FD_MSG		"/xsk_map_fd"
+-#define UDS_SOCK			"/tmp/afxdp.sock"
+ #define UDS_CONNECT_MSG			"/connect"
+ #define UDS_HOST_OK_MSG			"/host_ok"
+ #define UDS_HOST_NAK_MSG		"/host_nak"
+@@ -171,6 +172,7 @@ struct pmd_internals {
+ 	bool custom_prog_configured;
+ 	bool force_copy;
+ 	bool use_cni;
++	char dp_path[PATH_MAX];
+ 	struct bpf_map *map;
+ 
+ 	struct rte_ether_addr eth_addr;
+@@ -191,6 +193,7 @@ struct pmd_process_private {
+ #define ETH_AF_XDP_BUDGET_ARG			"busy_budget"
+ #define ETH_AF_XDP_FORCE_COPY_ARG		"force_copy"
+ #define ETH_AF_XDP_USE_CNI_ARG			"use_cni"
++#define ETH_AF_XDP_DP_PATH_ARG			"dp_path"
+ 
+ static const char * const valid_arguments[] = {
+ 	ETH_AF_XDP_IFACE_ARG,
+@@ -201,6 +204,7 @@ static const char * const valid_arguments[] = {
+ 	ETH_AF_XDP_BUDGET_ARG,
+ 	ETH_AF_XDP_FORCE_COPY_ARG,
+ 	ETH_AF_XDP_USE_CNI_ARG,
++	ETH_AF_XDP_DP_PATH_ARG,
+ 	NULL
+ };
+ 
+@@ -1338,7 +1342,7 @@ configure_preferred_busy_poll(struct pkt_rx_queue *rxq)
+ }
+ 
+ static int
+-init_uds_sock(struct sockaddr_un *server)
++init_uds_sock(struct sockaddr_un *server, const char *dp_path)
+ {
+ 	int sock;
+ 
+@@ -1349,7 +1353,7 @@ init_uds_sock(struct sockaddr_un *server)
+ 	}
+ 
+ 	server->sun_family = AF_UNIX;
+-	strlcpy(server->sun_path, UDS_SOCK, sizeof(server->sun_path));
++	strlcpy(server->sun_path, dp_path, sizeof(server->sun_path));
+ 
+ 	if (connect(sock, (struct sockaddr *)server, sizeof(struct sockaddr_un)) < 0) {
+ 		close(sock);
+@@ -1369,7 +1373,7 @@ struct msg_internal {
+ };
+ 
+ static int
+-send_msg(int sock, char *request, int *fd)
++send_msg(int sock, char *request, int *fd, const char *dp_path)
+ {
+ 	int snd;
+ 	struct iovec iov;
+@@ -1380,7 +1384,7 @@ send_msg(int sock, char *request, int *fd)
+ 
+ 	memset(&dst, 0, sizeof(dst));
+ 	dst.sun_family = AF_UNIX;
+-	strlcpy(dst.sun_path, UDS_SOCK, sizeof(dst.sun_path));
++	strlcpy(dst.sun_path, dp_path, sizeof(dst.sun_path));
+ 
+ 	/* Initialize message header structure */
+ 	memset(&msgh, 0, sizeof(msgh));
+@@ -1458,7 +1462,7 @@ read_msg(int sock, char *response, struct sockaddr_un *s, int *fd)
+ 
+ static int
+ make_request_cni(int sock, struct sockaddr_un *server, char *request,
+-		 int *req_fd, char *response, int *out_fd)
++		 int *req_fd, char *response, int *out_fd, const char *dp_path)
+ {
+ 	int rval;
+ 
+@@ -1470,7 +1474,7 @@ make_request_cni(int sock, struct sockaddr_un *server, char *request,
+ 	if (req_fd == NULL)
+ 		rval = write(sock, request, strlen(request));
+ 	else
+-		rval = send_msg(sock, request, req_fd);
++		rval = send_msg(sock, request, req_fd, dp_path);
+ 
+ 	if (rval < 0) {
+ 		AF_XDP_LOG(ERR, "Write error %s\n", strerror(errno));
+@@ -1494,7 +1498,7 @@ check_response(char *response, char *exp_resp, long size)
+ }
+ 
+ static int
+-get_cni_fd(char *if_name)
++get_cni_fd(char *if_name, const char *dp_path)
+ {
+ 	char request[UDS_MAX_CMD_LEN], response[UDS_MAX_CMD_RESP];
+ 	char hostname[MAX_LONG_OPT_SZ], exp_resp[UDS_MAX_CMD_RESP];
+@@ -1507,14 +1511,14 @@ get_cni_fd(char *if_name)
+ 		return -1;
+ 
+ 	memset(&server, 0, sizeof(server));
+-	sock = init_uds_sock(&server);
++	sock = init_uds_sock(&server, dp_path);
+ 	if (sock < 0)
+ 		return -1;
+ 
+ 	/* Initiates handshake to CNI send: /connect,hostname */
+ 	snprintf(request, sizeof(request), "%s,%s", UDS_CONNECT_MSG, hostname);
+ 	memset(response, 0, sizeof(response));
+-	if (make_request_cni(sock, &server, request, NULL, response, &out_fd) < 0) {
++	if (make_request_cni(sock, &server, request, NULL, response, &out_fd, dp_path) < 0) {
+ 		AF_XDP_LOG(ERR, "Error in processing cmd [%s]\n", request);
+ 		goto err_close;
+ 	}
+@@ -1528,7 +1532,7 @@ get_cni_fd(char *if_name)
+ 	/* Request for "/version" */
+ 	strlcpy(request, UDS_VERSION_MSG, UDS_MAX_CMD_LEN);
+ 	memset(response, 0, sizeof(response));
+-	if (make_request_cni(sock, &server, request, NULL, response, &out_fd) < 0) {
++	if (make_request_cni(sock, &server, request, NULL, response, &out_fd, dp_path) < 0) {
+ 		AF_XDP_LOG(ERR, "Error in processing cmd [%s]\n", request);
+ 		goto err_close;
+ 	}
+@@ -1536,7 +1540,7 @@ get_cni_fd(char *if_name)
+ 	/* Request for file descriptor for netdev name*/
+ 	snprintf(request, sizeof(request), "%s,%s", UDS_XSK_MAP_FD_MSG, if_name);
+ 	memset(response, 0, sizeof(response));
+-	if (make_request_cni(sock, &server, request, NULL, response, &out_fd) < 0) {
++	if (make_request_cni(sock, &server, request, NULL, response, &out_fd, dp_path) < 0) {
+ 		AF_XDP_LOG(ERR, "Error in processing cmd [%s]\n", request);
+ 		goto err_close;
+ 	}
+@@ -1558,7 +1562,7 @@ get_cni_fd(char *if_name)
+ 	/* Initiate close connection */
+ 	strlcpy(request, UDS_FIN_MSG, UDS_MAX_CMD_LEN);
+ 	memset(response, 0, sizeof(response));
+-	if (make_request_cni(sock, &server, request, NULL, response, &out_fd) < 0) {
++	if (make_request_cni(sock, &server, request, NULL, response, &out_fd, dp_path) < 0) {
+ 		AF_XDP_LOG(ERR, "Error in processing cmd [%s]\n", request);
+ 		goto err_close;
+ 	}
+@@ -1685,7 +1689,7 @@ xsk_configure(struct pmd_internals *internals, struct pkt_rx_queue *rxq,
+ 		int err, fd, map_fd;
+ 
+ 		/* get socket fd from CNI plugin */
+-		map_fd = get_cni_fd(internals->if_name);
++		map_fd = get_cni_fd(internals->if_name, internals->dp_path);
+ 		if (map_fd < 0) {
+ 			AF_XDP_LOG(ERR, "Failed to receive CNI plugin fd\n");
+ 			goto out_xsk;
+@@ -2010,7 +2014,8 @@ xdp_get_channels_info(const char *if_name, int *max_queues,
+ static int
+ parse_parameters(struct rte_kvargs *kvlist, char *if_name, int *start_queue,
+ 		 int *queue_cnt, int *shared_umem, char *prog_path,
+-		 int *busy_budget, int *force_copy, int *use_cni)
++		 int *busy_budget, int *force_copy, int *use_cni,
++		 char *dp_path)
+ {
+ 	int ret;
+ 
+@@ -2056,6 +2061,11 @@ parse_parameters(struct rte_kvargs *kvlist, char *if_name, int *start_queue,
+ 	if (ret < 0)
+ 		goto free_kvlist;
+ 
++	ret = rte_kvargs_process(kvlist, ETH_AF_XDP_DP_PATH_ARG,
++				 &parse_prog_arg, dp_path);
++	if (ret < 0)
++		goto free_kvlist;
++
+ free_kvlist:
+ 	rte_kvargs_free(kvlist);
+ 	return ret;
+@@ -2095,7 +2105,7 @@ static struct rte_eth_dev *
+ init_internals(struct rte_vdev_device *dev, const char *if_name,
+ 	       int start_queue_idx, int queue_cnt, int shared_umem,
+ 	       const char *prog_path, int busy_budget, int force_copy,
+-	       int use_cni)
++	       int use_cni, const char *dp_path)
+ {
+ 	const char *name = rte_vdev_device_name(dev);
+ 	const unsigned int numa_node = dev->device.numa_node;
+@@ -2125,6 +2135,7 @@ init_internals(struct rte_vdev_device *dev, const char *if_name,
+ 	internals->shared_umem = shared_umem;
+ 	internals->force_copy = force_copy;
+ 	internals->use_cni = use_cni;
++    strlcpy(internals->dp_path, dp_path, PATH_MAX);
+ 
+ 	if (xdp_get_channels_info(if_name, &internals->max_queue_cnt,
+ 				  &internals->combined_queue_cnt)) {
+@@ -2315,6 +2326,7 @@ rte_pmd_af_xdp_probe(struct rte_vdev_device *dev)
+ 	int busy_budget = -1, ret;
+ 	int force_copy = 0;
+ 	int use_cni = 0;
++    char dp_path[PATH_MAX] = {'\0'};
+ 	struct rte_eth_dev *eth_dev = NULL;
+ 	const char *name = rte_vdev_device_name(dev);
+ 
+@@ -2357,7 +2369,7 @@ rte_pmd_af_xdp_probe(struct rte_vdev_device *dev)
+ 
+ 	if (parse_parameters(kvlist, if_name, &xsk_start_queue_idx,
+ 			     &xsk_queue_cnt, &shared_umem, prog_path,
+-			     &busy_budget, &force_copy, &use_cni) < 0) {
++			     &busy_budget, &force_copy, &use_cni, dp_path) < 0) {
+ 		AF_XDP_LOG(ERR, "Invalid kvargs value\n");
+ 		return -EINVAL;
+ 	}
+@@ -2374,6 +2386,13 @@ rte_pmd_af_xdp_probe(struct rte_vdev_device *dev)
+ 			return -EINVAL;
+ 	}
+ 
++	if (use_cni && !strnlen(dp_path, PATH_MAX)) {
++ 		snprintf(dp_path, sizeof(dp_path), "%s/%s/%s", DP_BASE_PATH, if_name, DP_UDS_SOCK);
++		AF_XDP_LOG(INFO, "'%s' parameter not provided, setting value to '%s'\n",
++			ETH_AF_XDP_DP_PATH_ARG, dp_path);
++	}
++
++
+ 	if (strlen(if_name) == 0) {
+ 		AF_XDP_LOG(ERR, "Network interface must be specified\n");
+ 		return -EINVAL;
+@@ -2397,7 +2416,7 @@ rte_pmd_af_xdp_probe(struct rte_vdev_device *dev)
+ 
+ 	eth_dev = init_internals(dev, if_name, xsk_start_queue_idx,
+ 				 xsk_queue_cnt, shared_umem, prog_path,
+-				 busy_budget, force_copy, use_cni);
++				 busy_budget, force_copy, use_cni, dp_path);
+ 	if (eth_dev == NULL) {
+ 		AF_XDP_LOG(ERR, "Failed to init internals\n");
+ 		return -1;
+@@ -2458,4 +2477,5 @@ RTE_PMD_REGISTER_PARAM_STRING(net_af_xdp,
+ 			      "xdp_prog=<string> "
+ 			      "busy_budget=<int> "
+ 			      "force_copy=<int> "
+-			      "use_cni=<int> ");
++			      "use_cni=<int> "
++			      "dp_path=<string> ");
+-- 
+2.41.0
+
diff --git a/0002-net-af_xdp-support-AF_XDP-DP-pinned-maps.patch b/0002-net-af_xdp-support-AF_XDP-DP-pinned-maps.patch
new file mode 100644
index 0000000000..b2374a0fd3
--- /dev/null
+++ b/0002-net-af_xdp-support-AF_XDP-DP-pinned-maps.patch
@@ -0,0 +1,322 @@
+From 34300b22f61e9968e7d67a332ae05fe09377e6b5 Mon Sep 17 00:00:00 2001
+From: Maryam Tahhan <mtahhan@redhat.com>
+Date: Fri, 9 Feb 2024 06:39:51 -0500
+Subject: [PATCH 2/2] net/af_xdp: support AF_XDP DP pinned maps
+
+Enable the AF_XDP PMD to retrieve the xskmap
+from a pinned eBPF map. This map is expected
+to be pinned by an external entity like the
+AF_XDP Device Plugin. This enabled unprivileged
+pods to create and use AF_XDP sockets.
+
+Signed-off-by: Maryam Tahhan <mtahhan@redhat.com>
+---
+ drivers/net/af_xdp/rte_eth_af_xdp.c | 113 ++++++++++++++++++++--------
+ 1 file changed, 82 insertions(+), 31 deletions(-)
+
+diff --git a/drivers/net/af_xdp/rte_eth_af_xdp.c b/drivers/net/af_xdp/rte_eth_af_xdp.c
+index 0ade2b367c..beebbb44d2 100644
+--- a/drivers/net/af_xdp/rte_eth_af_xdp.c
++++ b/drivers/net/af_xdp/rte_eth_af_xdp.c
+@@ -83,8 +83,9 @@ RTE_LOG_REGISTER_DEFAULT(af_xdp_logtype, NOTICE);
+ 
+ #define ETH_AF_XDP_MP_KEY "afxdp_mp_send_fds"
+ 
+-#define DP_BASE_PATH			"/tmp"
+-#define DP_UDS_SOCK             "afxdp.sock"
++#define DP_BASE_PATH			"/tmp/afxdp_dp/"
++#define DP_UDS_SOCK				"afxdp.sock"
++#define DP_XSK_MAP				"xsks_map"
+ #define MAX_LONG_OPT_SZ			64
+ #define UDS_MAX_FD_NUM			2
+ #define UDS_MAX_CMD_LEN			64
+@@ -172,6 +173,7 @@ struct pmd_internals {
+ 	bool custom_prog_configured;
+ 	bool force_copy;
+ 	bool use_cni;
++    bool use_pinned_map;
+ 	char dp_path[PATH_MAX];
+ 	struct bpf_map *map;
+ 
+@@ -193,6 +195,7 @@ struct pmd_process_private {
+ #define ETH_AF_XDP_BUDGET_ARG			"busy_budget"
+ #define ETH_AF_XDP_FORCE_COPY_ARG		"force_copy"
+ #define ETH_AF_XDP_USE_CNI_ARG			"use_cni"
++#define ETH_AF_XDP_USE_PINNED_MAP_ARG	"use_pinned_map"
+ #define ETH_AF_XDP_DP_PATH_ARG			"dp_path"
+ 
+ static const char * const valid_arguments[] = {
+@@ -204,6 +207,7 @@ static const char * const valid_arguments[] = {
+ 	ETH_AF_XDP_BUDGET_ARG,
+ 	ETH_AF_XDP_FORCE_COPY_ARG,
+ 	ETH_AF_XDP_USE_CNI_ARG,
++    ETH_AF_XDP_USE_PINNED_MAP_ARG,
+ 	ETH_AF_XDP_DP_PATH_ARG,
+ 	NULL
+ };
+@@ -1245,6 +1249,22 @@ xsk_umem_info *xdp_umem_configure(struct pmd_internals *internals,
+ }
+ #endif
+ 
++static int
++get_pinned_map(const char *dp_path, int *map_fd)
++{
++
++	*map_fd  = bpf_obj_get(dp_path);
++	if (!*map_fd) {
++		AF_XDP_LOG(ERR, "Failed to find xsks_map in %s\n", dp_path);
++		return -1;
++	}
++
++	AF_XDP_LOG(INFO, "Successfully retrieved map %s with fd %d\n",
++				dp_path, *map_fd);
++
++	return 0;
++}
++
+ static int
+ load_custom_xdp_prog(const char *prog_path, int if_index, struct bpf_map **map)
+ {
+@@ -1461,7 +1481,7 @@ read_msg(int sock, char *response, struct sockaddr_un *s, int *fd)
+ }
+ 
+ static int
+-make_request_cni(int sock, struct sockaddr_un *server, char *request,
++make_request_dp(int sock, struct sockaddr_un *server, char *request,
+ 		 int *req_fd, char *response, int *out_fd, const char *dp_path)
+ {
+ 	int rval;
+@@ -1498,7 +1518,7 @@ check_response(char *response, char *exp_resp, long size)
+ }
+ 
+ static int
+-get_cni_fd(char *if_name, const char *dp_path)
++get_xskmap_fd(char *if_name, const char *dp_path)
+ {
+ 	char request[UDS_MAX_CMD_LEN], response[UDS_MAX_CMD_RESP];
+ 	char hostname[MAX_LONG_OPT_SZ], exp_resp[UDS_MAX_CMD_RESP];
+@@ -1518,7 +1538,7 @@ get_cni_fd(char *if_name, const char *dp_path)
+ 	/* Initiates handshake to CNI send: /connect,hostname */
+ 	snprintf(request, sizeof(request), "%s,%s", UDS_CONNECT_MSG, hostname);
+ 	memset(response, 0, sizeof(response));
+-	if (make_request_cni(sock, &server, request, NULL, response, &out_fd, dp_path) < 0) {
++	if (make_request_dp(sock, &server, request, NULL, response, &out_fd, dp_path) < 0) {
+ 		AF_XDP_LOG(ERR, "Error in processing cmd [%s]\n", request);
+ 		goto err_close;
+ 	}
+@@ -1532,7 +1552,7 @@ get_cni_fd(char *if_name, const char *dp_path)
+ 	/* Request for "/version" */
+ 	strlcpy(request, UDS_VERSION_MSG, UDS_MAX_CMD_LEN);
+ 	memset(response, 0, sizeof(response));
+-	if (make_request_cni(sock, &server, request, NULL, response, &out_fd, dp_path) < 0) {
++	if (make_request_dp(sock, &server, request, NULL, response, &out_fd, dp_path) < 0) {
+ 		AF_XDP_LOG(ERR, "Error in processing cmd [%s]\n", request);
+ 		goto err_close;
+ 	}
+@@ -1540,7 +1560,7 @@ get_cni_fd(char *if_name, const char *dp_path)
+ 	/* Request for file descriptor for netdev name*/
+ 	snprintf(request, sizeof(request), "%s,%s", UDS_XSK_MAP_FD_MSG, if_name);
+ 	memset(response, 0, sizeof(response));
+-	if (make_request_cni(sock, &server, request, NULL, response, &out_fd, dp_path) < 0) {
++	if (make_request_dp(sock, &server, request, NULL, response, &out_fd, dp_path) < 0) {
+ 		AF_XDP_LOG(ERR, "Error in processing cmd [%s]\n", request);
+ 		goto err_close;
+ 	}
+@@ -1562,7 +1582,7 @@ get_cni_fd(char *if_name, const char *dp_path)
+ 	/* Initiate close connection */
+ 	strlcpy(request, UDS_FIN_MSG, UDS_MAX_CMD_LEN);
+ 	memset(response, 0, sizeof(response));
+-	if (make_request_cni(sock, &server, request, NULL, response, &out_fd, dp_path) < 0) {
++	if (make_request_dp(sock, &server, request, NULL, response, &out_fd, dp_path) < 0) {
+ 		AF_XDP_LOG(ERR, "Error in processing cmd [%s]\n", request);
+ 		goto err_close;
+ 	}
+@@ -1631,7 +1651,7 @@ xsk_configure(struct pmd_internals *internals, struct pkt_rx_queue *rxq,
+ #endif
+ 
+ 	/* Disable libbpf from loading XDP program */
+-	if (internals->use_cni)
++	if (internals->use_cni || internals->use_pinned_map)
+ 		cfg.libbpf_flags |= XSK_LIBBPF_FLAGS__INHIBIT_PROG_LOAD;
+ 
+ 	if (strnlen(internals->prog_path, PATH_MAX)) {
+@@ -1686,22 +1706,40 @@ xsk_configure(struct pmd_internals *internals, struct pkt_rx_queue *rxq,
+ 	}
+ 
+ 	if (internals->use_cni) {
+-		int err, fd, map_fd;
++		int err, map_fd= -1;
+ 
+-		/* get socket fd from CNI plugin */
+-		map_fd = get_cni_fd(internals->if_name, internals->dp_path);
++        AF_XDP_LOG(INFO, "use_cni set: %s\n", internals->dp_path);
++		/* get socket fd from AF_XDP plugin */
++		map_fd = get_xskmap_fd(internals->if_name, internals->dp_path);
+ 		if (map_fd < 0) {
+ 			AF_XDP_LOG(ERR, "Failed to receive CNI plugin fd\n");
+ 			goto out_xsk;
+ 		}
+-		/* get socket fd */
+-		fd = xsk_socket__fd(rxq->xsk);
+-		err = bpf_map_update_elem(map_fd, &rxq->xsk_queue_idx, &fd, 0);
++
++		/* update xskmap */
++		err = xsk_socket__update_xskmap(rxq->xsk, map_fd);
++		if (err) {
++			AF_XDP_LOG(ERR, "Failed to insert unprivileged xsk in map.\n");
++			goto out_xsk;
++		}
++	} else if (internals->use_pinned_map) {
++        int err, map_fd= -1;
++
++		/* get socket fd from AF_XDP plugin */
++		AF_XDP_LOG(INFO, "use_pinned_map set: %s\n", internals->dp_path);
++		err = get_pinned_map(internals->dp_path, &map_fd);
++		if (err < 0 || map_fd < 0) {
++			AF_XDP_LOG(ERR, "Failed to retrieve pinned map fd\n");
++			goto out_xsk;
++        }
++
++		/* update xskmap */
++		err = xsk_socket__update_xskmap(rxq->xsk, map_fd);
+ 		if (err) {
+ 			AF_XDP_LOG(ERR, "Failed to insert unprivileged xsk in map.\n");
+ 			goto out_xsk;
+ 		}
+-	} else if (rxq->busy_budget) {
++    } else if (rxq->busy_budget) {
+ 		ret = configure_preferred_busy_poll(rxq);
+ 		if (ret) {
+ 			AF_XDP_LOG(ERR, "Failed configure busy polling.\n");
+@@ -1872,13 +1910,13 @@ static const struct eth_dev_ops ops = {
+ 	.get_monitor_addr = eth_get_monitor_addr,
+ };
+ 
+-/* CNI option works in unprivileged container environment
+- * and ethernet device functionality will be reduced. So
+- * additional customiszed eth_dev_ops struct is needed
+- * for cni. Promiscuous enable and disable functionality
+- * is removed.
++/* ops_device_plugin option works in unprivileged container
++ * environment and ethernet device functionality will be
++ * reduced. So additional customized eth_dev_ops struct is needed
++ * for AF_XDP DP support. Promiscuous enable and disable
++ * functionality is removed.
+  **/
+-static const struct eth_dev_ops ops_cni = {
++static const struct eth_dev_ops ops_device_plugin = {
+ 	.dev_start = eth_dev_start,
+ 	.dev_stop = eth_dev_stop,
+ 	.dev_close = eth_dev_close,
+@@ -2014,7 +2052,7 @@ xdp_get_channels_info(const char *if_name, int *max_queues,
+ static int
+ parse_parameters(struct rte_kvargs *kvlist, char *if_name, int *start_queue,
+ 		 int *queue_cnt, int *shared_umem, char *prog_path,
+-		 int *busy_budget, int *force_copy, int *use_cni,
++		 int *busy_budget, int *force_copy, int *use_cni, int *use_pinned_map,
+ 		 char *dp_path)
+ {
+ 	int ret;
+@@ -2061,6 +2099,11 @@ parse_parameters(struct rte_kvargs *kvlist, char *if_name, int *start_queue,
+ 	if (ret < 0)
+ 		goto free_kvlist;
+ 
++    ret = rte_kvargs_process(kvlist, ETH_AF_XDP_USE_PINNED_MAP_ARG,
++				 &parse_integer_arg, use_pinned_map);
++	if (ret < 0)
++		goto free_kvlist;
++
+ 	ret = rte_kvargs_process(kvlist, ETH_AF_XDP_DP_PATH_ARG,
+ 				 &parse_prog_arg, dp_path);
+ 	if (ret < 0)
+@@ -2105,7 +2148,7 @@ static struct rte_eth_dev *
+ init_internals(struct rte_vdev_device *dev, const char *if_name,
+ 	       int start_queue_idx, int queue_cnt, int shared_umem,
+ 	       const char *prog_path, int busy_budget, int force_copy,
+-	       int use_cni, const char *dp_path)
++	       int use_cni, int use_pinned_map ,const char *dp_path)
+ {
+ 	const char *name = rte_vdev_device_name(dev);
+ 	const unsigned int numa_node = dev->device.numa_node;
+@@ -2135,6 +2178,7 @@ init_internals(struct rte_vdev_device *dev, const char *if_name,
+ 	internals->shared_umem = shared_umem;
+ 	internals->force_copy = force_copy;
+ 	internals->use_cni = use_cni;
++    internals->use_pinned_map = use_pinned_map;
+     strlcpy(internals->dp_path, dp_path, PATH_MAX);
+ 
+ 	if (xdp_get_channels_info(if_name, &internals->max_queue_cnt,
+@@ -2194,10 +2238,10 @@ init_internals(struct rte_vdev_device *dev, const char *if_name,
+ 	eth_dev->data->dev_link = pmd_link;
+ 	eth_dev->data->mac_addrs = &internals->eth_addr;
+ 	eth_dev->data->dev_flags |= RTE_ETH_DEV_AUTOFILL_QUEUE_XSTATS;
+-	if (!internals->use_cni)
+-		eth_dev->dev_ops = &ops;
++	if (internals->use_cni || internals->use_pinned_map)
++		eth_dev->dev_ops = &ops_device_plugin;
+ 	else
+-		eth_dev->dev_ops = &ops_cni;
++		eth_dev->dev_ops = &ops;
+ 
+ 	eth_dev->rx_pkt_burst = eth_af_xdp_rx;
+ 	eth_dev->tx_pkt_burst = eth_af_xdp_tx;
+@@ -2326,6 +2370,7 @@ rte_pmd_af_xdp_probe(struct rte_vdev_device *dev)
+ 	int busy_budget = -1, ret;
+ 	int force_copy = 0;
+ 	int use_cni = 0;
++    int use_pinned_map = 0;
+     char dp_path[PATH_MAX] = {'\0'};
+ 	struct rte_eth_dev *eth_dev = NULL;
+ 	const char *name = rte_vdev_device_name(dev);
+@@ -2369,18 +2414,18 @@ rte_pmd_af_xdp_probe(struct rte_vdev_device *dev)
+ 
+ 	if (parse_parameters(kvlist, if_name, &xsk_start_queue_idx,
+ 			     &xsk_queue_cnt, &shared_umem, prog_path,
+-			     &busy_budget, &force_copy, &use_cni, dp_path) < 0) {
++			     &busy_budget, &force_copy, &use_cni, &use_pinned_map, dp_path) < 0) {
+ 		AF_XDP_LOG(ERR, "Invalid kvargs value\n");
+ 		return -EINVAL;
+ 	}
+ 
+-	if (use_cni && busy_budget > 0) {
++	if ((use_cni || use_pinned_map) && busy_budget > 0) {
+ 		AF_XDP_LOG(ERR, "When '%s' parameter is used, '%s' parameter is not valid\n",
+ 			ETH_AF_XDP_USE_CNI_ARG, ETH_AF_XDP_BUDGET_ARG);
+ 		return -EINVAL;
+ 	}
+ 
+-	if (use_cni && strnlen(prog_path, PATH_MAX)) {
++	if ((use_cni || use_pinned_map) && strnlen(prog_path, PATH_MAX)) {
+ 		AF_XDP_LOG(ERR, "When '%s' parameter is used, '%s' parameter is not valid\n",
+ 			ETH_AF_XDP_USE_CNI_ARG, ETH_AF_XDP_PROG_ARG);
+ 			return -EINVAL;
+@@ -2392,6 +2437,11 @@ rte_pmd_af_xdp_probe(struct rte_vdev_device *dev)
+ 			ETH_AF_XDP_DP_PATH_ARG, dp_path);
+ 	}
+ 
++    if (use_pinned_map && !strnlen(dp_path, PATH_MAX)) {
++ 		snprintf(dp_path, sizeof(dp_path), "%s/%s/%s", DP_BASE_PATH, if_name, DP_XSK_MAP);
++		AF_XDP_LOG(INFO, "'%s' parameter not provided, setting value to '%s'\n",
++			ETH_AF_XDP_DP_PATH_ARG, dp_path);
++	}
+ 
+ 	if (strlen(if_name) == 0) {
+ 		AF_XDP_LOG(ERR, "Network interface must be specified\n");
+@@ -2416,7 +2466,7 @@ rte_pmd_af_xdp_probe(struct rte_vdev_device *dev)
+ 
+ 	eth_dev = init_internals(dev, if_name, xsk_start_queue_idx,
+ 				 xsk_queue_cnt, shared_umem, prog_path,
+-				 busy_budget, force_copy, use_cni, dp_path);
++				 busy_budget, force_copy, use_cni, use_pinned_map, dp_path);
+ 	if (eth_dev == NULL) {
+ 		AF_XDP_LOG(ERR, "Failed to init internals\n");
+ 		return -1;
+@@ -2478,4 +2528,5 @@ RTE_PMD_REGISTER_PARAM_STRING(net_af_xdp,
+ 			      "busy_budget=<int> "
+ 			      "force_copy=<int> "
+ 			      "use_cni=<int> "
++			      "use_pinned_map=<int> "
+ 			      "dp_path=<string> ");
+-- 
+2.41.0
+
diff --git a/drivers/net/af_xdp/rte_eth_af_xdp.c b/drivers/net/af_xdp/rte_eth_af_xdp.c
index 0ade2b367c..8f02ad215f 100644
--- a/drivers/net/af_xdp/rte_eth_af_xdp.c
+++ b/drivers/net/af_xdp/rte_eth_af_xdp.c
@@ -83,8 +83,9 @@ RTE_LOG_REGISTER_DEFAULT(af_xdp_logtype, NOTICE);
 
 #define ETH_AF_XDP_MP_KEY "afxdp_mp_send_fds"
 
-#define DP_BASE_PATH			"/tmp"
-#define DP_UDS_SOCK             "afxdp.sock"
+#define DP_BASE_PATH			"/tmp/afxdp_dp/"
+#define DP_UDS_SOCK				"afxdp.sock"
+#define DP_XSK_MAP				"xsks_map"
 #define MAX_LONG_OPT_SZ			64
 #define UDS_MAX_FD_NUM			2
 #define UDS_MAX_CMD_LEN			64
@@ -172,6 +173,7 @@ struct pmd_internals {
 	bool custom_prog_configured;
 	bool force_copy;
 	bool use_cni;
+    bool use_pinned_map;
 	char dp_path[PATH_MAX];
 	struct bpf_map *map;
 
@@ -193,6 +195,7 @@ struct pmd_process_private {
 #define ETH_AF_XDP_BUDGET_ARG			"busy_budget"
 #define ETH_AF_XDP_FORCE_COPY_ARG		"force_copy"
 #define ETH_AF_XDP_USE_CNI_ARG			"use_cni"
+#define ETH_AF_XDP_USE_PINNED_MAP_ARG	"use_pinned_map"
 #define ETH_AF_XDP_DP_PATH_ARG			"dp_path"
 
 static const char * const valid_arguments[] = {
@@ -204,6 +207,7 @@ static const char * const valid_arguments[] = {
 	ETH_AF_XDP_BUDGET_ARG,
 	ETH_AF_XDP_FORCE_COPY_ARG,
 	ETH_AF_XDP_USE_CNI_ARG,
+    ETH_AF_XDP_USE_PINNED_MAP_ARG,
 	ETH_AF_XDP_DP_PATH_ARG,
 	NULL
 };
@@ -1245,6 +1249,22 @@ xsk_umem_info *xdp_umem_configure(struct pmd_internals *internals,
 }
 #endif
 
+static int
+get_pinned_map(const char *dp_path, int *map_fd)
+{
+
+	*map_fd  = bpf_obj_get(dp_path);
+	if (!*map_fd) {
+		AF_XDP_LOG(ERR, "Failed to find xsks_map in %s\n", dp_path);
+		return -1;
+	}
+
+	AF_XDP_LOG(INFO, "Successfully retrieved map %s with fd %d\n",
+				dp_path, *map_fd);
+
+	return 0;
+}
+
 static int
 load_custom_xdp_prog(const char *prog_path, int if_index, struct bpf_map **map)
 {
@@ -1461,7 +1481,7 @@ read_msg(int sock, char *response, struct sockaddr_un *s, int *fd)
 }
 
 static int
-make_request_cni(int sock, struct sockaddr_un *server, char *request,
+make_request_dp(int sock, struct sockaddr_un *server, char *request,
 		 int *req_fd, char *response, int *out_fd, const char *dp_path)
 {
 	int rval;
@@ -1498,7 +1518,7 @@ check_response(char *response, char *exp_resp, long size)
 }
 
 static int
-get_cni_fd(char *if_name, const char *dp_path)
+get_xskmap_fd(char *if_name, const char *dp_path)
 {
 	char request[UDS_MAX_CMD_LEN], response[UDS_MAX_CMD_RESP];
 	char hostname[MAX_LONG_OPT_SZ], exp_resp[UDS_MAX_CMD_RESP];
@@ -1518,7 +1538,7 @@ get_cni_fd(char *if_name, const char *dp_path)
 	/* Initiates handshake to CNI send: /connect,hostname */
 	snprintf(request, sizeof(request), "%s,%s", UDS_CONNECT_MSG, hostname);
 	memset(response, 0, sizeof(response));
-	if (make_request_cni(sock, &server, request, NULL, response, &out_fd, dp_path) < 0) {
+	if (make_request_dp(sock, &server, request, NULL, response, &out_fd, dp_path) < 0) {
 		AF_XDP_LOG(ERR, "Error in processing cmd [%s]\n", request);
 		goto err_close;
 	}
@@ -1532,7 +1552,7 @@ get_cni_fd(char *if_name, const char *dp_path)
 	/* Request for "/version" */
 	strlcpy(request, UDS_VERSION_MSG, UDS_MAX_CMD_LEN);
 	memset(response, 0, sizeof(response));
-	if (make_request_cni(sock, &server, request, NULL, response, &out_fd, dp_path) < 0) {
+	if (make_request_dp(sock, &server, request, NULL, response, &out_fd, dp_path) < 0) {
 		AF_XDP_LOG(ERR, "Error in processing cmd [%s]\n", request);
 		goto err_close;
 	}
@@ -1540,7 +1560,7 @@ get_cni_fd(char *if_name, const char *dp_path)
 	/* Request for file descriptor for netdev name*/
 	snprintf(request, sizeof(request), "%s,%s", UDS_XSK_MAP_FD_MSG, if_name);
 	memset(response, 0, sizeof(response));
-	if (make_request_cni(sock, &server, request, NULL, response, &out_fd, dp_path) < 0) {
+	if (make_request_dp(sock, &server, request, NULL, response, &out_fd, dp_path) < 0) {
 		AF_XDP_LOG(ERR, "Error in processing cmd [%s]\n", request);
 		goto err_close;
 	}
@@ -1562,7 +1582,7 @@ get_cni_fd(char *if_name, const char *dp_path)
 	/* Initiate close connection */
 	strlcpy(request, UDS_FIN_MSG, UDS_MAX_CMD_LEN);
 	memset(response, 0, sizeof(response));
-	if (make_request_cni(sock, &server, request, NULL, response, &out_fd, dp_path) < 0) {
+	if (make_request_dp(sock, &server, request, NULL, response, &out_fd, dp_path) < 0) {
 		AF_XDP_LOG(ERR, "Error in processing cmd [%s]\n", request);
 		goto err_close;
 	}
@@ -1631,7 +1651,7 @@ xsk_configure(struct pmd_internals *internals, struct pkt_rx_queue *rxq,
 #endif
 
 	/* Disable libbpf from loading XDP program */
-	if (internals->use_cni)
+	if (internals->use_cni || internals->use_pinned_map)
 		cfg.libbpf_flags |= XSK_LIBBPF_FLAGS__INHIBIT_PROG_LOAD;
 
 	if (strnlen(internals->prog_path, PATH_MAX)) {
@@ -1686,22 +1706,40 @@ xsk_configure(struct pmd_internals *internals, struct pkt_rx_queue *rxq,
 	}
 
 	if (internals->use_cni) {
-		int err, fd, map_fd;
+		int err, map_fd= -1;
 
-		/* get socket fd from CNI plugin */
-		map_fd = get_cni_fd(internals->if_name, internals->dp_path);
+        AF_XDP_LOG(INFO, "use_cni set: %s\n", internals->dp_path);
+		/* get socket fd from AF_XDP plugin */
+		map_fd = get_xskmap_fd(internals->if_name, internals->dp_path);
 		if (map_fd < 0) {
 			AF_XDP_LOG(ERR, "Failed to receive CNI plugin fd\n");
 			goto out_xsk;
 		}
-		/* get socket fd */
-		fd = xsk_socket__fd(rxq->xsk);
-		err = bpf_map_update_elem(map_fd, &rxq->xsk_queue_idx, &fd, 0);
+
+		/* update xskmap */
+		err = xsk_socket__update_xskmap(rxq->xsk, map_fd);
 		if (err) {
 			AF_XDP_LOG(ERR, "Failed to insert unprivileged xsk in map.\n");
 			goto out_xsk;
 		}
-	} else if (rxq->busy_budget) {
+	} else if (internals->use_pinned_map) {
+        int err, map_fd= -1;
+
+		/* get socket fd from AF_XDP plugin */
+		AF_XDP_LOG(INFO, "use_pinned_map set: %s\n", internals->dp_path);
+		err = get_pinned_map(internals->dp_path, &map_fd);
+		if (err < 0 || map_fd < 0) {
+			AF_XDP_LOG(ERR, "Failed to retrieve pinned map fd\n");
+			goto out_xsk;
+        }
+
+		/* update xskmap */
+		err = xsk_socket__update_xskmap(rxq->xsk, map_fd);
+		if (err) {
+			AF_XDP_LOG(ERR, "Failed to insert unprivileged xsk in map.\n");
+			goto out_xsk;
+		}
+    } else if (rxq->busy_budget) {
 		ret = configure_preferred_busy_poll(rxq);
 		if (ret) {
 			AF_XDP_LOG(ERR, "Failed configure busy polling.\n");
@@ -1872,13 +1910,13 @@ static const struct eth_dev_ops ops = {
 	.get_monitor_addr = eth_get_monitor_addr,
 };
 
-/* CNI option works in unprivileged container environment
- * and ethernet device functionality will be reduced. So
- * additional customiszed eth_dev_ops struct is needed
- * for cni. Promiscuous enable and disable functionality
- * is removed.
+/* ops_device_plugin option works in unprivileged container
+ * environment and ethernet device functionality will be
+ * reduced. So additional customized eth_dev_ops struct is needed
+ * for AF_XDP DP support. Promiscuous enable and disable
+ * functionality is removed.
  **/
-static const struct eth_dev_ops ops_cni = {
+static const struct eth_dev_ops ops_device_plugin = {
 	.dev_start = eth_dev_start,
 	.dev_stop = eth_dev_stop,
 	.dev_close = eth_dev_close,
@@ -2014,7 +2052,7 @@ xdp_get_channels_info(const char *if_name, int *max_queues,
 static int
 parse_parameters(struct rte_kvargs *kvlist, char *if_name, int *start_queue,
 		 int *queue_cnt, int *shared_umem, char *prog_path,
-		 int *busy_budget, int *force_copy, int *use_cni,
+		 int *busy_budget, int *force_copy, int *use_cni, int *use_pinned_map,
 		 char *dp_path)
 {
 	int ret;
@@ -2061,6 +2099,11 @@ parse_parameters(struct rte_kvargs *kvlist, char *if_name, int *start_queue,
 	if (ret < 0)
 		goto free_kvlist;
 
+    ret = rte_kvargs_process(kvlist, ETH_AF_XDP_USE_PINNED_MAP_ARG,
+				 &parse_integer_arg, use_pinned_map);
+	if (ret < 0)
+		goto free_kvlist;
+
 	ret = rte_kvargs_process(kvlist, ETH_AF_XDP_DP_PATH_ARG,
 				 &parse_prog_arg, dp_path);
 	if (ret < 0)
@@ -2105,7 +2148,7 @@ static struct rte_eth_dev *
 init_internals(struct rte_vdev_device *dev, const char *if_name,
 	       int start_queue_idx, int queue_cnt, int shared_umem,
 	       const char *prog_path, int busy_budget, int force_copy,
-	       int use_cni, const char *dp_path)
+	       int use_cni, int use_pinned_map ,const char *dp_path)
 {
 	const char *name = rte_vdev_device_name(dev);
 	const unsigned int numa_node = dev->device.numa_node;
@@ -2135,6 +2178,7 @@ init_internals(struct rte_vdev_device *dev, const char *if_name,
 	internals->shared_umem = shared_umem;
 	internals->force_copy = force_copy;
 	internals->use_cni = use_cni;
+    internals->use_pinned_map = use_pinned_map;
     strlcpy(internals->dp_path, dp_path, PATH_MAX);
 
 	if (xdp_get_channels_info(if_name, &internals->max_queue_cnt,
@@ -2194,10 +2238,13 @@ init_internals(struct rte_vdev_device *dev, const char *if_name,
 	eth_dev->data->dev_link = pmd_link;
 	eth_dev->data->mac_addrs = &internals->eth_addr;
 	eth_dev->data->dev_flags |= RTE_ETH_DEV_AUTOFILL_QUEUE_XSTATS;
-	if (!internals->use_cni)
-		eth_dev->dev_ops = &ops;
-	else
-		eth_dev->dev_ops = &ops_cni;
+	if (internals->use_cni || internals->use_pinned_map) {
+        AF_XDP_LOG(DEBUG, "SETTING eth_dev->dev_ops = &ops_device_plugin\n");
+		eth_dev->dev_ops = &ops_device_plugin;
+	} else {
+        AF_XDP_LOG(DEBUG, "SETTING eth_dev->dev_ops = &ops_device_plugin\n");
+        eth_dev->dev_ops = &ops;
+    }
 
 	eth_dev->rx_pkt_burst = eth_af_xdp_rx;
 	eth_dev->tx_pkt_burst = eth_af_xdp_tx;
@@ -2326,6 +2373,7 @@ rte_pmd_af_xdp_probe(struct rte_vdev_device *dev)
 	int busy_budget = -1, ret;
 	int force_copy = 0;
 	int use_cni = 0;
+    int use_pinned_map = 0;
     char dp_path[PATH_MAX] = {'\0'};
 	struct rte_eth_dev *eth_dev = NULL;
 	const char *name = rte_vdev_device_name(dev);
@@ -2369,18 +2417,18 @@ rte_pmd_af_xdp_probe(struct rte_vdev_device *dev)
 
 	if (parse_parameters(kvlist, if_name, &xsk_start_queue_idx,
 			     &xsk_queue_cnt, &shared_umem, prog_path,
-			     &busy_budget, &force_copy, &use_cni, dp_path) < 0) {
+			     &busy_budget, &force_copy, &use_cni, &use_pinned_map, dp_path) < 0) {
 		AF_XDP_LOG(ERR, "Invalid kvargs value\n");
 		return -EINVAL;
 	}
 
-	if (use_cni && busy_budget > 0) {
+	if ((use_cni || use_pinned_map) && busy_budget > 0) {
 		AF_XDP_LOG(ERR, "When '%s' parameter is used, '%s' parameter is not valid\n",
 			ETH_AF_XDP_USE_CNI_ARG, ETH_AF_XDP_BUDGET_ARG);
 		return -EINVAL;
 	}
 
-	if (use_cni && strnlen(prog_path, PATH_MAX)) {
+	if ((use_cni || use_pinned_map) && strnlen(prog_path, PATH_MAX)) {
 		AF_XDP_LOG(ERR, "When '%s' parameter is used, '%s' parameter is not valid\n",
 			ETH_AF_XDP_USE_CNI_ARG, ETH_AF_XDP_PROG_ARG);
 			return -EINVAL;
@@ -2392,6 +2440,11 @@ rte_pmd_af_xdp_probe(struct rte_vdev_device *dev)
 			ETH_AF_XDP_DP_PATH_ARG, dp_path);
 	}
 
+    if (use_pinned_map && !strnlen(dp_path, PATH_MAX)) {
+ 		snprintf(dp_path, sizeof(dp_path), "%s/%s/%s", DP_BASE_PATH, if_name, DP_XSK_MAP);
+		AF_XDP_LOG(INFO, "'%s' parameter not provided, setting value to '%s'\n",
+			ETH_AF_XDP_DP_PATH_ARG, dp_path);
+	}
 
 	if (strlen(if_name) == 0) {
 		AF_XDP_LOG(ERR, "Network interface must be specified\n");
@@ -2416,7 +2469,7 @@ rte_pmd_af_xdp_probe(struct rte_vdev_device *dev)
 
 	eth_dev = init_internals(dev, if_name, xsk_start_queue_idx,
 				 xsk_queue_cnt, shared_umem, prog_path,
-				 busy_budget, force_copy, use_cni, dp_path);
+				 busy_budget, force_copy, use_cni, use_pinned_map, dp_path);
 	if (eth_dev == NULL) {
 		AF_XDP_LOG(ERR, "Failed to init internals\n");
 		return -1;
@@ -2478,4 +2531,5 @@ RTE_PMD_REGISTER_PARAM_STRING(net_af_xdp,
 			      "busy_budget=<int> "
 			      "force_copy=<int> "
 			      "use_cni=<int> "
+			      "use_pinned_map=<int> "
 			      "dp_path=<string> ");
-- 
2.41.0

